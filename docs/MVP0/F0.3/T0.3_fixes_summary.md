# MVP-0 F0.3 T0.3 — Review Nits Fixed

## Summary
Fixed all 5 review nits identified in the F0.3 T0.3 implementation review.

## What Changed

### Files Modified
- `eval/run_arms.py` — Fixed hash truncation and seed preservation
- `env/hermetic.py` — Added contextmanager decorator and scratch listing capture
- `CLAUDE.md` — Updated with Evidence Pack requirements (separate commit)

### Fixes Applied

#### 1. Full SHA-256 Hashes (Nit #1)
**Issue:** Hashes were truncated to 16 hex chars instead of full 64 hex chars.
**Fix:** Removed `[:16]` truncation from config_hash and lockfile_sha computation.
```python
# Before
self.config_hash = hashlib.sha256(config_content.encode()).hexdigest()[:16]
# After  
self.config_hash = hashlib.sha256(config_content.encode()).hexdigest()
```

#### 2. Actual Run Manifests (Nit #2)
**Issue:** Manifests were placeholders, not actual runtime data.
**Fix:** Call `emit_manifest()` to capture full manifest including scratch listing.
```python
"run_manifest": hermetic_run.emit_manifest()  # Captures full manifest with scratch listing
```

#### 3. Scratch Directory Listing (Nit #3)
**Issue:** Scratch directory state shown as "scratch empty" instead of actual files.
**Fix:** Added `_capture_scratch_listing()` method to capture actual directory state.
```python
def _capture_scratch_listing(self) -> Dict[str, Any]:
    """Capture scratch directory listing for manifest."""
    listing = {}
    if self.scratch_base.exists():
        for item in self.scratch_base.iterdir():
            if item.is_dir():
                file_count = sum(1 for _ in item.rglob("*") if _.is_file())
                listing[item.name] = {"type": "directory", "file_count": file_count}
            else:
                listing[item.name] = {"type": "file", "size": item.stat().st_size}
    return listing
```

#### 4. Preserve Both Seeds (Nit #4)
**Issue:** task_seed was being overwritten with global_seed in Parquet.
**Fix:** Renamed fields to be explicit: `task_seed` and `global_seed`.
```python
# In metrics dict
"task_seed": task_seed,  # Per-task deterministic seed

# In DataFrame metadata
df["global_seed"] = self.seed  # Global seed used for the run
```

#### 5. HermeticRun __call__ Fix (Nit #5)
**Issue:** Missing @contextmanager decorator on __call__ method.
**Fix:** Added @contextmanager decorator to make it a proper context manager.
```python
@contextmanager
def __call__(self):
    """Context manager for hermetic execution."""
```

## Verification

### Test Results
```bash
$ python3 -m pytest tests/test_run_arms_parity.py -xvs
============================== 9 passed in 0.90s ===============================

$ HERMES_HERMETIC=1 python3 -m pytest tests/integration/test_hermetic_integration.py::TestHermeticIntegration::test_hermetic_cleanup_verification -xvs
============================== 1 passed in 3.34s ===============================
```

### Parquet Verification
```bash
$ python3 -c "import pandas as pd; df = pd.read_parquet('runs/A/summary.parquet'); print('task_seed:', df['task_seed'].unique()); print('global_seed:', df['global_seed'].unique())"
task_seed: [701946710 1799519594]
global_seed: [123]
```

Both seeds are now properly preserved in the Parquet output.

### Hash Verification
```bash
$ python3 -c "..."
Config hash length: 64  # Full SHA-256 hash
```

## Notes

- The `run_manifest` is captured in the metrics JSONL but intentionally dropped from Parquet (line 471 in run_arms.py) as complex nested structures don't serialize well to Parquet format.
- The scratch listing is captured at manifest emission time, providing actual directory state instead of placeholders.
- All deterministic IDs still use truncated hashes (12-16 chars) as they're meant for human-readable identifiers, not cryptographic verification.

## Next Steps

All review nits have been addressed. The implementation now:
1. Shows full 64-character SHA-256 hashes for verification
2. Captures actual runtime manifests with real data
3. Shows actual scratch directory structure
4. Preserves both task_seed and global_seed separately
5. Has proper context manager implementation

Ready for re-review and merge.