# T1.2 — PM Arm: Benefit-Aware MCP Anchoring

## What Changed

- Added `agents/pm_arm.py` implementing benefit-aware anchoring logic with conservative thresholds
- Enhanced `mcp/client.py` with `put_if_absent()` and `resolve_bytes()` methods
- Added comprehensive unit tests in `tests/agents/test_pm_arm.py` covering all decision branches
- Implements the never-regress-bytes principle through careful threshold and benefit analysis

## Why

T1.2 requires PM arm to intelligently decide between inline data and MCP anchors based on actual byte savings. This ensures we never increase message size by anchoring small payloads where the reference would be longer than the original data.

## How It Works

### Decision Logic

1. **Hard Capacity (256KB)**: Always anchor if `len(data) >= HARD_CAP`
2. **Benefit-Aware Thresholds**:
   - Logs/Diffs: 1KB minimum before considering anchoring
   - Patches: 4KB minimum (typical patches are 200-500B and should stay inline)
3. **Reference Size Check**: Only anchor if `len(ref) < len(data)`

### Reference Format
```
mcp://{kind}/{sha256_first_16_chars}
```
Example: `mcp://logs/a3f5c8d2b1e94f6a` (typically 28-35 bytes)

### TTL Configuration
- **Logs**: 24 hours (ephemeral debugging data)
- **Diffs**: 7 days (review/audit trail)
- **Patches**: 7 days (reproducibility window)

### Metrics Tracking
The `PMMetrics` dataclass tracks:
- `anchors_created`: Total anchors created
- `bytes_saved`: Cumulative bytes saved (inline_len - ref_len)
- `inline_count`: Items kept inline
- `anchor_count`: Items anchored

## Acceptance Criteria

### Unit Test Coverage ✅

All decision branches covered:
1. **None payload** → Returns `(b"", False)`
2. **Tiny patch (≤500B)** → Stays inline (benefit-aware)
3. **Log <1KB** → Inline; **≥1KB** → Anchor
4. **Patch <4KB** → Inline; **≥4KB** → Anchor
5. **Huge payload (≥256KB)** → Always anchor
6. **Bytes saved** calculation verified
7. **put_if_absent** idempotency tested

### Realistic Scenarios ✅

1. **5-50KB log blob**:
   - Input: 25KB log with timestamps and messages
   - Output: `mcp://logs/{hash}` reference
   - Bytes saved: ~24,970 bytes

2. **200-500B patch**:
   - Input: Small diff changing 2-3 lines
   - Output: Original patch inline
   - Bytes saved: 0 (correctly avoids regression)

## Never-Regress Principle

The implementation guarantees we never increase bytes through anchoring:

```python
if len(ref.encode("utf-8")) >= inline_len:
    return data, False  # Keep inline
```

This check ensures that even if data exceeds the threshold, it stays inline if the reference would be longer.

## SWE-bench Lite Integration

The PM arm is designed for SWE-bench Lite evaluation where:
- Test logs can range from 100B to 100KB+
- Patches are typically small (200-500B for single-line fixes)
- Large multi-file changes may exceed 10KB

The thresholds are tuned to:
- Keep small diagnostic patches inline for debugging
- Anchor verbose test output to reduce message size
- Balance storage overhead vs. transport efficiency

## Example Usage

```python
from agents.pm_arm import PMAnchorManager, PMMetrics
from mcp.client import MCPClient

# Initialize
mcp_client = MCPClient(server)
metrics = PMMetrics()
manager = PMAnchorManager(mcp_client, metrics)

# Small patch - stays inline
patch = b"diff --git a/file.py..." # 300 bytes
result, anchored = manager.maybe_anchor(patch, "patches")
assert not anchored  # Stays inline

# Large log - gets anchored
log = b"[Test output...]" * 1000  # 15KB
result, anchored = manager.maybe_anchor(log, "logs")
assert anchored  # Returns mcp://logs/...
assert metrics.bytes_saved > 14000
```

## References

- MCP Server implementation: `mcp/server.py` (F1.1)
- SWE-bench Lite dataset: Official counts (dev=23, test=300)
- Git apply flags: `--3way -p{0,1,2}` for patch application (PR #3)
- Protobuf serialization: `SerializeToString()` for wire size (PR #4)