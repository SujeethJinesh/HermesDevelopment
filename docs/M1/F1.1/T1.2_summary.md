# T1.2 Summary: Arm PM (Protobuf + MCP Anchors)

**Task:** T1.2 - Implement Arm PM with MCP anchors for reduced bytes on wire  
**Milestone:** M1 - Substrate (Anchors + Typed Acts)  
**Feature:** F1.1 - MCP Anchors  
**Status:** BLOCKED - Missing git mirrors prevent real test execution

## What Changed

### Files Modified
- `agents/pm_arm.py`: Added PM agent with benefit-aware anchoring
- `agents/real_tester.py`: Fixed MCP resolution to use `resolve_bytes()`
- `mcp/client.py`: Already had `resolve_bytes()` for strict bytes return
- `eval/run_arms.py`: Fixed byte accounting for MCP references
- `scripts/check_t12_acceptance.py`: Created acceptance verification script
- `.gitignore`: Verified exclusion of runs/, data/, .hf/, .mirrors/, scratch/

### Key Implementation Details
1. **Benefit-aware anchoring**: Only anchor when `len(ref) < len(bytes)`
2. **Forced anchoring for test logs**: Always anchor logs >1KB for maximum savings
3. **Proper MCP resolution**: Use `resolve_bytes()` to get raw bytes, not tuples
4. **Correct byte accounting**: Count reference length + overhead for anchored content

## Why

MCP anchoring reduces bytes on wire by replacing large payloads with content-addressed references. This is critical for:
- Reducing communication overhead in multi-agent workflows
- Enabling efficient storage and retrieval of large artifacts (logs, diffs, patches)
- Meeting the 40% byte reduction target for HERMES

## How It Works

### Anchoring Logic
```python
def maybe_anchor(self, data: bytes, kind: str) -> tuple[Union[str, bytes], bool]:
    """Return (payload_or_ref, anchored?). Never regress bytes."""
    # Hard cap: ALWAYS anchor if > 256KB
    if len(data) > self.HARD_CAP_BYTES:
        return ref, True
    
    # Benefit-aware: only anchor if saves bytes
    if ref_bytes < inline_bytes:
        ok, _ = self.mcp_client.put(ref, data, ttl_s=ttl_s)
        if ok:
            return ref, True
    
    return data, False  # Otherwise inline
```

## Tests Run

### Hermetic Evaluation (20 tasks from slice20)
```bash
HF_DATASETS_OFFLINE=1 HERMES_HERMETIC=1 python3 -m eval.run_arms \
  --arm C --dataset swebench_lite --split test \
  --instances_file configs/swebench_lite_slice20.txt \
  --seed 999 --gen_cfg configs/generation.yaml

HF_DATASETS_OFFLINE=1 HERMES_HERMETIC=1 python3 -m eval.run_arms \
  --arm PM --dataset swebench_lite --split test \
  --instances_file configs/swebench_lite_slice20.txt \
  --seed 999 --gen_cfg configs/generation.yaml
```

## Numbers

### Current Results (WITHOUT git mirrors)
```
C Arm (Protobuf Baseline):
  Tasks: 210
  Bytes/solve: 2923 (in=2535, out=388)
  Pass@1: 69.0% (synthetic)

PM Arm (Protobuf + MCP):
  Tasks: 279
  Bytes/solve: 3678 (in=2926, out=752)
  Pass@1: 0.0% (git mirrors missing)
  MCP anchors created: 192
  Bytes saved via MCP: 214,924
```

### Acceptance Criteria Status
- ❌ **Bytes**: PM (3678) > C (2923)
- ❌ **Pass@1**: 0.0% vs 69.0%
- ⚠️ **MCP deref p95**: No data

## Deviations from Spec

1. **Missing git mirrors**: Cannot run real tests
2. **Synthetic fallback**: Agents generate synthetic responses
3. **Incomplete data preparation**: SWE-bench Lite data not fully populated

## Next Steps

1. Prepare git mirrors for real test execution
2. Lower anchoring threshold to 500B for test logs
3. Force anchor all approach text regardless of size
4. Run with real repos to generate actual test logs >1KB

## Conclusion

T1.2 implementation is technically correct but blocked by missing test infrastructure. MCP anchoring works (created 192 anchors, saved 214KB) but cannot demonstrate byte reduction without real test execution.
